
#简介

Linux使用的shell叫做Bourne Again SHell, 简称bash. 也是基于GNU架构发展出来的

Linux的/etc/shells文件中, 提供了所有可以使用的shells:

1. /bin/sh (已经被 /bin/bash 所取代)
1. /bin/bash (就是 Linux 默认的 shell)
1. /bin/ksh (Kornshell 由 AT&T Bell lab. 发展出来的，兼容于 bash)
1. /bin/tcsh (整合 C Shell ，提供更多的功能)
1. /bin/csh (已经被 /bin/tcsh 所取代)
1. /bin/zsh (基于 ksh 发展出来的，功能更强大的 shell)

系统有些服务在运行过程中, 会去检查使用者能够使用的shells, 而这些shell的查询就是藉由/etc/shells这个文件

----

##Bash

Bash的主要优点:
1. 命令编修能力(history

    能够记忆使用过的命令
    命令记录存储在家目录的.bash_history里, 记录着前一次登录以前所运行的命令, 而这一次登录所运行的命令则被缓存在内存中, 当你成功徐晓系统后 该命令记忆才会被记录到.bash_history中
1. 命令与文件不全功能
1. 命令别名配置功能:

    `alias lm='ls -al'`
1. 工作控制, 前景背景控制
1. 程序化脚本
1. 通配符

----

##内建命令type

利用type这个命令可以观察一个命令来自于外部命令还是内建在bash当中

1. `type ls`    `ls is /bin/ls`
1. `type cd`    `alias is a shell builtin`

----

##命令的下达

反斜杠(\)可以用来给命令分行, 好让命令可以继续在下一行输入. 不过[Enter]安静是紧接着反斜杠(\)的, 两者中间没有其他自负. 因为**\\仅跳脱紧接着的下一个字符**而已.

****

#Hello world

    #!/bin/bash
    #This is a very simple example
    echo Hello world

1. `#!`是说明hello这个文件的类型. Linux系统根据`#!`及该字符串后面的信息确定该文件的类型. 
1. ` # This is a...`是Bash程序的注释. 从'#'开始到行尾都会被视为程序的注释.
1. `echo`的功能是把后面的字符串输出到标准输出中去.

----

##运行方式

1. `bash hello`
1. `sh hello #sh是指向bash的一个链接` 
1. `chmod u+x hello` `./hello`

****

#变量

Bash中的变量是不能含有保留字, 也不能含有'-'等保留自字符, 也不能含有**空格**

不同用户在使用同一个变量时, 所获取到的值不一定是一致的. 比如说在使用mail命令时, 系统将会访问MAIL这个变量. 对于root来说, 这个变量的内容可能是/var/spool/mail/root, 而对于dmtsai来说, 可能就是/var/spool/mail/dmtsai

----

##影响bash环境操作的变量

由于系统需要一些变量来提供他数据的存取, 所以就有一些所谓的环境变量来读入系统中了. 这些环境变量通常以大写字符来表示, 比如PATH. 命令是透过PATH这个变量的内容所记录的路径来搜寻命令的.

----

##变量的取用与修改

取用:

1. `echo $variable`
1. `echo $PATH`
1. `echo ${PATH}`

修改: 

1. `myname=VBird`

在bash中, 如果一个变量名称尚未被配置, 默认的内容是空的

----

##变量的配置守则

1. `myname=VBird`   correct
1. `myname = VBird` wrong, 等号两边不能直接接空格符
1. `2myname=VBird`  worng, 变量名称只能是英文字母与数字, 但是开头字符不能是数字
1. 变量内容若有空格符可使用双引号"或单引号'将变量内容结合起来，但

    1. 双引号内的特殊字符如 $ 等，可以保有原本的特性，如下所示：

        `var="lang is $LANG"`则`echo $var`可得`lang is en_US`
    1. 单引号内的特殊字符则仅为一般字符 (纯文本)，如下所示：
    
        `var='lang is $LANG'`则`echo $var`可得`lang is $LANG`
1. 可用跳脱字符` \ `将特殊符号(如 [Enter], $, \, 空格符, '等)变成一般字符；
1. 在一串命令中，还需要藉由其他的命令提供的信息，可以使用反单引号\`命令\`或 $(命令)。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！ 例如想要取得核心版本的配置：

    `version=$(uname -r)`再`echo $version`可得`2.6.18-128.el5`
1. 若该变量为扩增变量内容时，则可用 "$变量名称"或${变量} 累加内容，如下所示：

    `PATH="$PATH":/home/bin`
1. 若该变量需要在其他子程序运行，则需要以 export 来使变量变成环境变量：

    `export PATH`
    一般情况下, 父程序的自定义变量是无法在子程序内使用的. 但透过export将变量变成环境变量后, 就能够在子程序地下应用了.
1. 通常大写字符为系统默认变量，自行配置变量可以使用小写字符，方便判断 (纯粹依照使用者兴趣与嗜好) ；
1. 取消变量的方法为使用 unset ：`unset 变量名称`例如取消 myname 的配置：

----

##环境变量介绍

环境变量可以使用`env`命令来列出:

1. HOME

    代表用户的家目录。还记得我们可以使用 cd ~ 去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量啦～ 有很多程序都可能会取用到这个变量的值！
1. SHELL

    告知我们，目前这个环境使用的 SHELL 是哪支程序？ Linux 默认使用 /bin/bash 的啦！
1. HISTSIZE

    这个与『历史命令』有关，亦即是， 我们曾经下达过的命令可以被系统记录下来，而记录的『笔数』则是由这个值来配置的。
1. MAIL

    当我们使用 mail 这个命令在收信时，系统会去读取的邮件信箱文件 (mailbox)。
1. PATH

    就是运行文件搜寻的路径啦～目录与目录中间以冒号(:)分隔， 由于文件的搜寻是依序由 PATH 的变量内的目录来查询，所以，目录的顺序也是重要的喔。
1. LANG

    这个重要！就是语系数据～很多信息都会用到他， 举例来说，当我们在启动某些 perl 的程序语言文件时，他会主动的去分析语系数据文件， 如果发现有他无法解析的编码语系，可能会产生错误喔！一般来说，我们中文编码通常是 zh_TW.Big5 或者是 zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。 这部分我们会在下个小节做介绍的！
1. RANDOM

    这个玩意儿就是『随机随机数』的变量啦！目前大多数的 distributions 都会有随机数生成器，那就是 /dev/random 这个文件。 我们可以透过这个随机数文件相关的变量 ($RANDOM) 来随机取得随机数值喔。在 BASH 的环境下，这个 RANDOM 变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于 0~32767 的数值。万一我想要使用 0~9 之间的数值呢？呵呵～利用 declare 宣告数值类型， 然后这样做就可以了：

    `[root@www ~]# declare -i number=$RANDOM*10/32768 ; echo $number`

----

此外, bash中还有一些与bash操作接口有关的变量, 以及用户自己定义的变量存在的. 这时要用`set`来酱在bash中的变量通通显示出来.

1. PS1：(提示字符的配置)

    这是 PS1 (数字的 1 不是英文字母)，这个东西就是我们的[命令提示字符]喔！ 当我们每次按下 [Enter] 按键去运行某个命令后，最后要再次出现提示字符时， 就会主动去读取这个变量值了。上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息， 每个 distributions 的 bash 默认的 PS1 变量内容可能有些许的差异，不要紧，[习惯你自己的习惯]就好了。 你可以用 man bash (注3)去查询一下 PS1 的相关说明，以理解底下的一些符号意义。

    - \d ：可显示出[星期 月 日]的日期格式，如："Mon Feb 2"
    - \H ：完整的主机名。举例来说，鸟哥的练习机为[www.vbird.tsai]
    - \h ：仅取主机名在第一个小数点之前的名字，如鸟哥主机则为[www]后面省略
    - \t ：显示时间，为 24 小时格式的[HH:MM:SS]
    - \T ：显示时间，为 12 小时格式的[HH:MM:SS]
    - \A ：显示时间，为 24 小时格式的[HH:MM]
    - \@ ：显示时间，为 12 小时格式的[am/pm]样式
    - \u ：目前使用者的账号名称，如[root]；
    - \v ：BASH 的版本信息，如鸟哥的测试主板本为 3.2.25(1)，仅取[3.2]显示
    - \w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；
    - \W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。
    - \# ：下达的第几个命令。
    - \$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是$～

    好了，让我们来看看 CentOS 默认的 PS1 内容吧：[[\u@\h \W]\$]，现在你知道那些反斜杠后的数据意义了吧？ 要注意喔！那个反斜杠后的数据为PS1的特殊功能，与bash的变量配置没关系啦！不要搞混了喔！那你现在知道为何你的命令提示字符是：[ [root@www ~]# ]了吧？好了，那么假设我想要有类似底下的提示字符：

        [root@www/home/dmtsai 16:50 #12]# 
    那个#代表第 12 次下达的命令。那么应该如何配置 PS1 呢？可以这样啊：

        [root@www ~ ]# cd /home
        [root@www home]# PS1='[\u@\h \w \A #\#]\$ '
        [root@www /home 17:02 #85]# 
1. $：(关于本 shell 的 PID)

    钱字号本身也是个变量喔！这个咚咚代表的是[目前这个 Shell 的线程代号]，亦即是所谓的 PID (Process ID)。 更多的程序观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，就可以用：[ echo $$ ]即可！出现的数字就是你的 PID 号码。
1. ?：(关于上个运行命令的回传值)

    什么？问号也是一个特殊的变量？没错！在 bash 里面这个变量可重要的很！ 这个变量是：[上一个运行的命令所回传的值]， 上面这句话的重点是[上一个命令]与[回传值]两个地方。当我们运行某些命令时， 这些命令都会回传一个运行后的代码。一般来说，如果成功的运行该命令， 则会回传一个 0 值，如果运行过程发生错误，就会回传[错误代码]才对！一般就是以非为 0 的数值来取代。 我们以底下的例子来看看：

    [root@www ~]# echo $SHELL
    /bin/bash                                  <==可顺利显示！没有错误！
    [root@www ~]# echo $?
    0                                          <==因为没问题，所以回传值为 0
    [root@www ~]# 12name=VBird
    -bash: 12name=VBird: command not found     <==发生错误了！bash回报有问题
    [root@www ~]# echo $?
    127                                        <==因为有问题，回传错误代码(非为0)
    \# 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜寻错误的原因喔！
    [root@www ~]# echo $?
    0
    \# 咦！怎么又变成正确了？这是因为 "?" 只与[上一个运行命令]有关，
    \# 所以，我们上一个命令是运行[ echo $? ]，当然没有错误，所以是 0 没错！
1. OSTYPE, HOSTTYPE, MACHTYPE：(主机硬件与核心的等级)

    我们在第零章、计算器概论内的 CPU 等级说明中谈过 CPU ， 目前个人计算机的 CPU 主要分为 32/64 位，其中 32 位又可分为 i386, i586, i686，而 64 位则称为 x86_64。 由于不同等级的 CPU 命令集不太相同，因此你的软件可能会针对某些 CPU 进行优化，以求取较佳的软件性能。 所以软件就有 i386, i686 及 x86_64 之分。以目前 (2009) 的主流硬件来说，几乎都是 x86_64 的天下！ 但是毕竟旧机器还是非常多，以鸟哥的环境来说，我用 P-III 等级的计算机，所以上头就发现我的等级是 i686 啦！

----

##export: 自定义变量转成环境变量

当你登陆 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的程序，被称为 PID 的就是。 接下来你在这个 bash 底下所下达的任何命令都是由这个 bash 所衍生出来的，那些被下达的命令就被称为子程序了. 

![ppid](./img/Bash/ppid.gif)

如上所示，我们在原本的 bash 底下运行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子程序)， 那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个命令运行的环境是实线的部分！若要回到原本的 bash 去， 就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。

而环境变量与自定义变量的区别就在于此. 因为子程序仅会继承父程序的环境变量， 子程序不会继承父程序的自定义变量啦！所以你在原本 bash 的自定义变量在进入了子程序后就会消失不见， 一直到你离开子程序并回到原本的父程序后，这个变量才会又出现！

于是, export命令就是将自定义变量导入到环境变量中:

    export 变量名称
如果仅下达 export 而没有接变量时，那么此时将会把所有的[环境变量]秀出来喔！

----

##影响显示结果的语系变量 (locale)

locale命令可以用来查询Linux系统到底支持了多少语系:

    locale -a
修订语系也是使用locale命令:

    locale                       <==后面不加任何选项与参数即可！
    LANG=en_US                   <==主语言的环境
    LC_CTYPE="en_US"             <==字符(文字)辨识的编码
    LC_NUMERIC="en_US"           <==数字系统的显示信息
    LC_TIME="en_US"              <==时间系统的显示数据
    LC_COLLATE="en_US"           <==字符串的比较与排序等
    LC_MONETARY="en_US"          <==币值格式的显示等
    LC_MESSAGES="en_US"          <==信息显示的内容，如菜单、错误信息等
    LC_ALL=                      <==整体语系的环境
基本上，你可以逐一配置每个与语系有关的变量数据，但事实上，如果其他的语系变量都未配置， 且你有配置 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代！

----







































